/**
 * @file Firestore Security Rules for MemoDams
 *
 * @corePhilosophy
 *   This ruleset enforces a strict user-ownership model. Users can only
 *   access their own data, including profiles, notes, tags, and files.
 *   Data consistency between the path and the document is validated on create
 *   and update operations.
 *
 * @dataStructure
 *   All data is nested under /users/{userId}, with subcollections for
 *   notes, tags, and files. This structure ensures data isolation between users.
 *
 * @keySecurityDecisions
 *   - User listing is disallowed for privacy.
 *   - All write operations require user authentication.
 *
 * @denormalizationForAuthorization
 *   The `userId` field is present on all documents within a user's data tree.
 *   This allows for fast, simple rules without extra reads.
 *
 * @structuralSegregation
 *   All private user data is stored under the /users/{userId} path,
 *   ensuring that there is no accidental public exposure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "user123", ... } } }
     * @allow (get) User with ID 'user123' can read their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) User with ID 'user123' can update their profile.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "user123", ... } } }
     * @allow (delete) User with ID 'user123' can delete their profile.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) User with ID 'user456' cannot create a profile for 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "user123", ... } } }
     * @deny (update) User with ID 'user456' cannot update the profile for 'user123'.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "user123", ... } } }
     * @principle Enforces document ownership for writes, validates userId on create and update.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to notes for a specific user.
     * @path /users/{userId}/notes/{noteId}
     * @allow (create) User with ID 'user123' can create a note in their notes collection.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "userId": "user123", ... } } }
     * @allow (get) User with ID 'user123' can read a note from their notes collection.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) User with ID 'user123' can update a note in their notes collection.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "userId": "user123", ... } } }
     * @allow (delete) User with ID 'user123' can delete a note from their notes collection.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) User with ID 'user456' cannot create a note in the 'user123' notes collection.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "userId": "user123", ... } } }
     * @deny (update) User with ID 'user456' cannot update a note in the 'user123' notes collection.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "userId": "user123", ... } } }
     * @principle Restricts access to a user's own data tree, enforces userId consistency, validates relational integrity.
     */
    match /users/{userId}/notes/{noteId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
        function isSignedIn() {
        return request.auth != null;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to tags for a specific user.
     * @path /users/{userId}/tags/{tagId}
     * @allow (create) User with ID 'user123' can create a tag in their tags collection.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "userId": "user123", ... } } }
     * @allow (get) User with ID 'user123' can read a tag from their tags collection.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) User with ID 'user123' can update a tag in their tags collection.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "userId": "user123", ... } } }
     * @allow (delete) User with ID 'user123' can delete a tag from their tags collection.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) User with ID 'user456' cannot create a tag in the 'user123' tags collection.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "userId": "user123", ... } } }
     * @deny (update) User with ID 'user456' cannot update a tag in the 'user123' tags collection.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "userId": "user123", ... } } }
     * @principle Restricts access to a user's own data tree, enforces userId consistency, validates relational integrity.
     */
    match /users/{userId}/tags/{tagId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
        function isSignedIn() {
        return request.auth != null;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to files for a specific user.
     * @path /users/{userId}/files/{fileId}
     * @allow (create) User with ID 'user123' can create a file in their files collection.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "userId": "user123", ... } } }
     * @allow (get) User with ID 'user123' can read a file from their files collection.
     *   Request: { "auth": { "uid": "user123" } }
     * @allow (update) User with ID 'user123' can update a file in their files collection.
     *   Request: { "auth": { "uid": "user123" }, "resource": { "data": { "userId": "user123", ... } } }
     * @allow (delete) User with ID 'user123' can delete a file from their files collection.
     *   Request: { "auth": { "uid": "user123" } }
     * @deny (create) User with ID 'user456' cannot create a file in the 'user123' files collection.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "userId": "user123", ... } } }
     * @deny (update) User with ID 'user456' cannot update a file in the 'user123' files collection.
     *   Request: { "auth": { "uid": "user456" }, "resource": { "data": { "userId": "user123", ... } } }
     * @principle Restricts access to a user's own data tree, enforces userId consistency, validates relational integrity.
     */
    match /users/{userId}/files/{fileId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
        function isSignedIn() {
        return request.auth != null;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }
  }
}